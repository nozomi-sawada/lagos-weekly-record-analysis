<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lagos Weekly Record Keyword Analysis (1891-1921)</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .header {
            background-color: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .description {
            margin: 10px 0 0 0;
            font-size: 14px;
            color: #555;
        }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #map {
            flex: 2;
            height: 100%;
            position: relative;
        }
        
        .sidebar {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            background-color: #fff;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }
        
        .nav-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        
        .nav-tab {
            padding: 10px 15px;
            background-color: #f8f9fa;
            font-weight: bold;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        
        .nav-tab:hover {
            background-color: #f0f0f0;
        }
        
        .nav-tab.active {
            border-bottom-color: #3388ff;
            background-color: #fff;
        }
        
        .tab-content {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        .location-list-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            font-weight: bold;
            border-bottom: 1px solid #eee;
        }
        
        .display-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .display-controls select {
            padding: 3px 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .display-controls input {
            padding: 3px 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .location-list {
            list-style: none;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            flex: 1;
        }
        
        .location-item {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .location-item:hover {
            background-color: #f5f5f5;
        }
        
        .location-item.active {
            background-color: #e5f2ff;
            border-left: 4px solid #3388ff;
        }
        
        .location-details {
            display: flex;
            flex-direction: column;
        }
        
        .location-name {
            font-weight: bold;
        }
        
        .location-count {
            font-size: 13px;
            color: #777;
        }
        
        .count-badge {
            background-color: #e8f0fe;
            color: #1a73e8;
            border-radius: 12px;
            padding: 4px 8px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .details-container {
            padding: 15px;
            border-top: 1px solid #ddd;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .details-title {
            font-size: 18px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .details-counts {
            display: flex;
            flex: 1;
        }
        
        .details-count {
            margin-left: 15px;
            font-size: 13px;
        }
        
        .details-count span {
            font-weight: bold;
            color: #1a73e8;
        }
        
        .toggle-quotes-btn {
            background-color: #3388ff;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .toggle-quotes-btn:hover {
            background-color: #2672e3;
        }
        
        .quote-section {
            margin-top: 10px;
        }
        
        .quote-header {
            font-size: 12px;
            text-transform: uppercase;
            color: #777;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        blockquote {
            margin: 10px 0;
            padding: 12px;
            border-left: 4px solid #3388ff;
            background-color: #f8f9fa;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .quote-source {
            text-align: right;
            font-style: italic;
            font-size: 12px;
            color: #777;
            margin-top: 5px;
        }
        
        .quote-relevance {
            display: flex;
            align-items: center;
            margin-top: 5px;
            font-size: 11px;
            color: #777;
            cursor: help;
        }
        
        .relevance-score {
            margin-left: 3px;
            margin-right: 5px;
            font-weight: bold;
            color: #1a73e8;
        }
        
        .relevance-meter {
            display: inline-block;
            width: 50px;
            height: 5px;
            background-color: #eee;
            margin-left: 5px;
            border-radius: 2px;
            overflow: hidden;
            cursor: help;
        }
        
        .relevance-fill {
            height: 100%;
            background-color: #3388ff;
        }
        
        /* Custom tooltip enhancement */
        .quote-relevance:hover .relevance-meter {
            box-shadow: 0 0 3px rgba(26, 115, 232, 0.5);
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3388ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background-color: #fdecea;
            color: #d93025;
            padding: 15px;
            border-radius: 4px;
            margin: 20px;
            text-align: center;
        }
        
        .legend {
            position: absolute;
            bottom: 25px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 400;
            font-size: 12px;
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .footer {
            padding: 8px;
            text-align: center;
            background-color: #f8f9fa;
            border-top: 1px solid #ddd;
            font-size: 12px;
            color: #777;
        }
        
        strong {
            background-color: #ffffbb;
            padding: 0 2px;
        }
        
        .file-upload {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            background-color: #f8f9fa;
            padding: 20px;
            text-align: center;
        }
        
        .file-upload-icon {
            font-size: 48px;
            color: #3388ff;
            margin-bottom: 15px;
        }
        
        .file-upload-text {
            margin-bottom: 20px;
            color: #555;
        }
        
        .file-upload-button {
            background-color: #3388ff;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            transition: background-color 0.3s;
        }
        
        .file-upload-button:hover {
            background-color: #2672e3;
        }
        
        .file-input {
            display: none;
        }
        
        .file-name {
            margin-top: 10px;
            font-size: 14px;
            color: #777;
        }
        
        .map-type-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 500;
            background: white;
            padding: 5px 10px;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            font-size: 12px;
        }
        
        /* Year filter styles */
        .filter-container {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        
        .filter-label {
            font-weight: bold;
            margin-right: 10px;
            font-size: 14px;
        }
        
        .filter-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .year-filter {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .period-filter {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .reset-filter {
            background-color: #f0f0f0;
            color: #555;
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .reset-filter:hover {
            background-color: #e0e0e0;
        }
        
        .filter-info {
            margin-top: 8px;
            font-size: 13px;
            color: #1a73e8;
            width: 100%;
        }

        /* Time period buttons */
        .periods-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
            gap: 5px;
        }
        
        .period-button {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .period-button:hover {
            background-color: #e0e0e0;
        }
        
        .period-button.active {
            background-color: #3388ff;
            color: white;
            border-color: #2672e3;
        }
        
        /* Keyword analysis styles */
        .keyword-analysis-container {
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
        }
        
        .keyword-search {
            display: flex;
            margin-bottom: 5px;
        }
        
        .keyword-search-tip {
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
            font-style: italic;
        }
        
        .keyword-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px 0 0 4px;
            font-size: 14px;
        }
        
        .keyword-search-btn {
            background-color: #3388ff;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .keyword-search-btn:hover {
            background-color: #2672e3;
        }
        
        .keyword-results {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .keyword-section {
            margin-bottom: 20px;
        }
        
        .keyword-section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #3388ff;
        }
        
        .related-terms {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .term-tag {
            background-color: #e8f0fe;
            color: #1a73e8;
            border-radius: 16px;
            padding: 5px 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
        }
        
        .term-count {
            background-color: #1a73e8;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 5px;
        }
        
        .theme-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .theme-card {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            width: calc(50% - 5px);
        }
        
        .theme-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #1a73e8;
        }
        
        .theme-words {
            font-size: 12px;
            color: #555;
        }
        
        .timeline-chart {
            height: 150px;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .bar-container {
            display: flex;
            align-items: flex-end;
            height: 100px;
            width: 100%;
            padding: 0 10px;
        }
        
        .year-bar {
            flex: 1;
            background-color: #4292c6;
            margin: 0 2px;
            min-width: 15px;
            position: relative;
            transition: height 0.3s;
        }
        
        .year-bar:hover {
            background-color: #2171b5;
        }
        
        .year-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #555;
        }
        
        .count-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #1a73e8;
            font-weight: bold;
        }
        
        /* Make layout responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            #map {
                height: 50vh;
            }
            
            .sidebar {
                max-width: none;
            }
            
            .filter-container {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .filter-controls {
                margin-top: 10px;
                width: 100%;
            }
            
            .theme-card {
                width: 100%;
            }
        }
        
        /* モーダルとチャート関連のスタイル - 強化版 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow-y: auto;
        }

        .modal-content {
            background-color: white;
            margin: 3% auto;  /* より上部に配置 */
            padding: 20px;
            width: 95%;      /* より広く */
            max-width: 1200px; /* 最大幅を増やす */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            max-height: 90vh; /* 画面の高さの90%に制限 */
            overflow: hidden; /* 内部でスクロールを許可 */
        }

        .chart-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }

        .chart-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            text-align: center;
        }

        .enlarged-chart {
            height: 500px;   /* より高く */
            margin: 10px 0;
            padding: 20px 5px; /* 左右のパディングを減らす */
            position: relative;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .enlarged-bar-container {
            display: flex;
            align-items: flex-end;
            height: 400px;   /* より高く */
            width: 100%;
            min-width: 100%;
            padding: 0 5px;  /* パディングを減らす */
            margin-top: 30px; /* 上部のラベル用に余白を追加 */
            position: relative;
            flex: 1;
            background-color: #f8f9fa;
            overflow-x: auto;
        }

        /* チャートのベースライン */
        .enlarged-bar-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #ddd;
            z-index: 1;
        }

        .enlarged-year-bar {
            flex: 0 0 auto;  /* flexでサイズを固定 */
            width: 30px;     /* 固定幅 */
            min-width: 30px; /* 最小幅を確保 */
            background-color: #4292c6;
            margin: 0 2px;
            min-height: 1px;
            position: relative;
            transition: background-color 0.2s;
        }

        .enlarged-year-bar:hover {
            background-color: #2171b5;
        }

        .enlarged-year-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg); /* 斜めに表示して重なりを防ぐ */
            transform-origin: top left;
            font-size: 11px;
            color: #555;
            font-weight: bold;
            white-space: nowrap;
        }

        .enlarged-count-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #1a73e8;
            font-weight: bold;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Lagos Weekly Record Keyword Analysis (1891-1921)</h1>
        <p class="description">
            Advanced analysis of keywords and themes in Lagos Weekly Record editorials, with focus on geographic mentions and contextual relationships.
            Upload your CSV file to begin analysis.
        </p>
    </div>
    
    <!-- ここが変更された部分: ファイルアップロードコンテナ -->
    <div id="file-upload-container" class="file-upload">
        <div class="file-upload-icon">📁</div>
        <div class="file-upload-text">
            Upload your CSV files to analyze Lagos Weekly Record data
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <div style="text-align: center;">
                <button class="file-upload-button" onclick="document.getElementById('csv-file').click()">
                    Select Analysis CSV
                </button>
                <input type="file" id="csv-file" class="file-input" accept=".csv" onchange="handleFileUpload(this.files)" />
                <div id="file-name" class="file-name"></div>
            </div>
            
            <div style="text-align: center;">
                <button class="file-upload-button" onclick="document.getElementById('location-csv-file').click()">
                    Upload Location Data
                </button>
                <input type="file" id="location-csv-file" class="file-input" accept=".csv" onchange="handleLocationFileUpload(this.files)" />
                <div id="location-file-name" class="file-name"></div>
            </div>
        </div>
        
        <div id="upload-status" style="font-size: 14px; color: #666; margin-top: 15px;"></div>
        <div id="start-analysis-container" style="margin-top: 20px; display: none;">
            <button class="file-upload-button" onclick="startAnalysis()">
                Start Analysis
            </button>
        </div>
    </div>
    
    <div id="visualization-container" style="display: none; height: 100%; flex: 1; display: flex; flex-direction: column;">
        <div class="container">
            <div id="map"></div>
            
            <div class="sidebar">
                <div class="nav-tabs">
                    <div class="nav-tab active" onclick="switchTab('geo-tab')">Geographic</div>
                    <div class="nav-tab" onclick="switchTab('keyword-tab')">Keyword Analysis</div>
                </div>
                
                <!-- Geographic Tab Content -->
                <div id="geo-tab" class="tab-content active">
                    <div class="filter-container">
                        <div class="filter-label">Filter by Time Period:</div>
                        <div class="periods-container" id="periods-container">
                            <!-- Will be populated with period buttons -->
                        </div>
                        <button class="reset-filter" onclick="resetFilters()">Show All Years</button>
                        <div class="filter-info" id="filter-info"></div>
                    </div>
                    <div class="location-list-header">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="location-header-text">Top Geographic Mentions</span>
                            <div class="display-controls">
                                <select id="display-mode" onchange="changeDisplayMode()">
                                    <option value="top">Top N Locations</option>
                                    <option value="threshold">Frequency Threshold</option>
                                </select>
                                <input type="number" id="display-value" min="5" max="100" value="30" style="width: 60px;" onchange="updateDisplaySetting()">
                            </div>
                        </div>
                    </div>
                    <ul class="location-list" id="location-list"></ul>
                    <div class="details-container" id="details-container" style="display: none;">
                        <div class="details-header">
                            <div class="details-title" id="details-title"></div>
                            <div class="details-counts">
                                <div class="details-count">Mentions: <span id="details-mentions"></span></div>
                                <div class="details-count">Articles: <span id="details-articles"></span></div>
                            </div>
                            <button id="toggle-quotes-btn" class="toggle-quotes-btn" onclick="toggleQuotes()">Show Quotes</button>
                        </div>
                        <div class="quote-section" id="quote-section" style="display: none;">
                            <div class="quote-header">Sample Quotes</div>
                            <div id="quotes-container"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Keyword Analysis Tab Content -->
                <div id="keyword-tab" class="tab-content">
                    <div class="keyword-analysis-container">
                        <div class="keyword-search">
                            <input type="text" id="keyword-input" class="keyword-input" placeholder="Enter keywords (e.g., Yoruba, Yorubas)" value="Yoruba, Yorubas">
                            <button class="keyword-search-btn" onclick="analyzeKeyword()">Analyze</button>
                        </div>
                        <div class="keyword-search-tip">Separate multiple terms with commas to include variations (e.g., "Yoruba, Yorubas")</div>
                        
                        <div class="keyword-results" id="keyword-results">
                            <!-- Initially empty, will be populated by JavaScript -->
                            <div style="text-align: center; color: #777; margin-top: 50px;">
                                Enter a keyword and click "Analyze" to see contextual patterns and related themes.
                                <br><br>
                                Try "Yoruba" to see detailed analysis of its usage in Lagos Weekly Record.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-title">Mention Frequency</div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #08306b;"></div>
                <span>300+ mentions</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2171b5;"></div>
                <span>150-300 mentions</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4292c6;"></div>
                <span>50-150 mentions</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #9ecae1;"></div>
                <span>&lt;50 mentions</span>
            </div>
        </div>
        
        <div class="loading" id="loading" style="display: none;">
            <div class="spinner"></div>
            <div>Processing Data...</div>
        </div>
    </div>
    
    <div class="footer">
        © 2025 Nozomi Sawada. All rights reserved. | Data from Lagos Weekly Record, 1891-1921 editorials
    </div>
    
    <!-- モーダル for enlarged chart -->
    <div id="chart-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal()">&times;</span>
            <div class="chart-title" id="modal-chart-title">Mentions Over Time</div>
            <div class="chart-subtitle" id="modal-chart-subtitle"></div>
            <div class="enlarged-chart" id="enlarged-chart"></div>
        </div>
    </div>

    <script>
        // Here we changed from 'const' to 'let'
        // Known locations with coordinates
        let locationCoordinates = {
            "Lagos": [6.4550, 3.3841],
            "Yoruba": [8.1574, 4.6123],
            "Africa": [9.0000, 18.0000],
            "West Africa": [8.0000, 0.0000],
            "Abeokuta": [7.1583, 3.3481],
            "Ibadan": [7.3775, 3.9470],
            "England": [52.3555, -1.1743],
            "Niger": [9.0820, 8.6753],
            "Ilorin": [8.5000, 4.5500],
            "Egba": [7.1583, 3.3481],
            "Europe": [48.0000, 10.0000],
            "Sierra Leone": [8.4606, -11.7799],
            "Oyo": [7.8500, 3.9333],
            "Gold Coast": [5.5500, -0.2000],
            "America": [37.0902, -95.7129],
            "London": [51.5074, -0.1278],
            "Benin": [6.3350, 5.6037],
            "Liberia": [6.4281, -9.4295],
            "Britain": [54.0000, -2.0000],
            "Porto Novo": [6.4969, 2.6283],
            "Ijebu": [6.8156, 3.9277],
            "Accra": [5.5600, -0.2057],
            "Ondo": [7.0960, 4.8305],
            "Dahomey": [8.0000, 2.0000],
            "Egypt": [26.8206, 30.8025],
            "France": [46.2276, 2.2137],
            "Togo": [8.6195, 0.8248],
            "India": [20.5937, 78.9629],
            // Adding more locations that might be relevant for 1891-1921 period
            "Germany": [51.1657, 10.4515],
            "United States": [37.0902, -95.7129],
            "South Africa": [-30.5595, 22.9375],
            "Nigeria": [9.0820, 8.6753],
            "Cape Coast": [5.1053, -1.2466],
            "Calabar": [4.9757, 8.3417],
            "Cameroon": [7.3697, 12.3547],
            "Belgian Congo": [-4.0383, 21.7587], // Now Democratic Republic of Congo
            "Sudan": [12.8628, 30.2176],
            "Ethiopia": [9.1450, 40.4897],
            "Kenya": [0.0236, 37.9062],
            "Senegal": [14.4974, -14.4524],
            "Gambia": [13.4432, -15.3101],
            "Freetown": [8.4657, -13.2317],
            "Kano": [12.0000, 8.5167],
            "Zaria": [11.0850, 7.7199],
            "Sokoto": [13.0667, 5.2333],
            "Warri": [5.5167, 5.7500]
        };

        // List of words to search for in the text
        let locationKeywords = Object.keys(locationCoordinates);

        // Important contextual keywords that might indicate relevance
        const importantKeywords = [
            "important", "significant", "key", "major", "critical", "essential", "crucial", 
            "notable", "remarkable", "prominent", "leading", "main", "principal", "chief",
            "central", "vital", "primary", "foremost", "dominant", "distinguished", "renowned",
            "eminent", "paramount", "preeminent", "notable", "famous", "capital", "government",
            "trade", "colonial", "development", "policy", "administration", "political", "economic",
            "social", "cultural", "historical", "traditional", "native", "indigenous", "foreign",
            "imperial", "commercial", "industrial", "agricultural", "educational", "religious",
            "military", "naval", "diplomatic", "strategic", "geographic", "demographic"
        ];

        // Words to exclude from related terms/themes (stop words)
        const stopWords = [
            "the", "and", "a", "an", "in", "on", "at", "to", "for", "with", "by", "of", "that", 
            "this", "as", "from", "be", "been", "being", "was", "were", "is", "are", "am", "have", 
            "has", "had", "will", "would", "shall", "should", "may", "might", "must", "can", "could", 
            "it", "its", "it's", "they", "them", "their", "we", "us", "our", "you", "your", "he", 
            "him", "his", "she", "her", "hers", "which", "who", "whom", "whose", "what", "where", 
            "when", "why", "how", "all", "any", "both", "each", "few", "more", "most", "other", 
            "some", "such", "no", "nor", "not", "only", "own", "same", "so", "than", "too", "very"
        ];

        // Variables to keep track of data and UI state
        let map;
        let allLocations = []; // Will store all processed locations data
        let filteredLocations = []; // Will store filtered locations
        let selectedLocation = null;
        let markers = {};
        let rawData = []; // Store original CSV data
        let availableYears = []; // Store unique years from data
        let selectedPeriod = null; // Current selected time period
        let displayMode = "top"; // 'top' or 'threshold'
        let displayValue = 30; // Default to show top 30 locations
        
        // Global variable to track upload status
        let analysisFileUploaded = false;
        let locationFileUploaded = false;
        let customLocationData = null; // Will store the uploaded location data
        
        // Handle location file upload
        function handleLocationFileUpload(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            document.getElementById('location-file-name').textContent = file.name;
            
            // Show loading notification
            document.getElementById('upload-status').textContent = "Reading location data...";
            
            // Read and process the file
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvData = e.target.result;
                processLocationCSV(csvData);
            };
            reader.onerror = function() {
                document.getElementById('upload-status').textContent = "Error reading location file!";
            };
            reader.readAsText(file);
        }
        
        // Process location CSV data
        function processLocationCSV(csvData) {
            // Parse CSV using PapaParse
            Papa.parse(csvData, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Log the column names to debug
                    console.log("Location CSV Headers:", results.meta.fields);
                    
                    // Check if the CSV has the required columns
                    const fields = results.meta.fields.map(field => field.toLowerCase());
                    if (!fields.includes('placename') || !fields.includes('latitude') || !fields.includes('longitude')) {
                        document.getElementById('upload-status').textContent = 
                            "Error: Location CSV must contain 'placename', 'latitude', and 'longitude' columns.";
                        return;
                    }
                    
                    // Process and store the location data
                    customLocationData = processLocationData(results.data);
                    
                    // Update status
                    const locationCount = Object.keys(customLocationData).length;
                    document.getElementById('upload-status').textContent = 
                        `Successfully loaded ${locationCount} locations. ${analysisFileUploaded ? "" : "Please upload analysis data."}`;
                    
                    locationFileUploaded = true;
                    updateStartButtonVisibility();
                },
                error: function(error) {
                    document.getElementById('upload-status').textContent = `Failed to parse location CSV: ${error.message}`;
                }
            });
        }
        
        // Process location data from CSV to format needed by application
        function processLocationData(data) {
            const locations = {};
            
            data.forEach(row => {
                // Get column names (accounting for case insensitivity)
                const placenameKey = Object.keys(row).find(
                    key => key.toLowerCase() === 'placename');
                const latKey = Object.keys(row).find(
                    key => key.toLowerCase() === 'latitude');
                const lngKey = Object.keys(row).find(
                    key => key.toLowerCase() === 'longitude');
                
                if (placenameKey && latKey && lngKey) {
                    const placename = row[placenameKey];
                    const lat = parseFloat(row[latKey]);
                    const lng = parseFloat(row[lngKey]);
                    
                    // Only add if we have valid coordinates
                    if (placename && !isNaN(lat) && !isNaN(lng)) {
                        locations[placename] = [lat, lng];
                    }
                }
            });
            
            return locations;
        }
        
        // Modified version of existing handleFileUpload function
        function handleFileUpload(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            document.getElementById('file-name').textContent = file.name;
            
            // Just store the file reference, don't process yet
            window.analysisFile = file;
            analysisFileUploaded = true;
            
            // Update status
            document.getElementById('upload-status').textContent = 
                `Analysis file loaded. ${locationFileUploaded ? "" : "Please upload location data."}`;
            
            updateStartButtonVisibility();
        }
        
        // Update visibility of the start button
        function updateStartButtonVisibility() {
            const startContainer = document.getElementById('start-analysis-container');
            if (analysisFileUploaded && locationFileUploaded) {
                startContainer.style.display = 'block';
            } else {
                startContainer.style.display = 'none';
            }
        }
        
        // Start the analysis with both files
        function startAnalysis() {
            // Show loading spinner
            document.getElementById('loading').style.display = 'flex';
            
            // Hide file upload container and show visualization container
            document.getElementById('file-upload-container').style.display = 'none';
            document.getElementById('visualization-container').style.display = 'flex';
            
            // Replace the default locationCoordinates with our custom data
            locationCoordinates = customLocationData;
            
            // Update the locationKeywords array from the new data
            locationKeywords = Object.keys(locationCoordinates);
            
            // Process the analysis file
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvData = e.target.result;
                processCSVData(csvData);
            };
            reader.onerror = function() {
                showError("Error reading analysis file");
            };
            reader.readAsText(window.analysisFile);
        }
        
        // Define periods for filtering
        const timePeriods = [
            { label: "1891-1895", start: 1891, end: 1895 },
            { label: "1896-1900", start: 1896, end: 1900 },
            { label: "1901-1905", start: 1901, end: 1905 },
            { label: "1906-1910", start: 1906, end: 1910 },
            { label: "1911-1915", start: 1911, end: 1915 },
            { label: "1916-1921", start: 1916, end: 1921 }
        ];
        
        // Tab switching functionality
        function switchTab(tabId) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Deactivate all tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            
            // Activate the tab button
            document.querySelector(`.nav-tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
        }
        
        // Process CSV data
        function processCSVData(csvData) {
            // Parse CSV using PapaParse
            Papa.parse(csvData, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Log the column names to debug
                    console.log("CSV Headers:", results.meta.fields);
                    
                    // Store raw data
                    rawData = results.data;
                    
                    // Extract available years
                    extractYears();
                    
                    // Setup period filter buttons
                    setupPeriodFilters();
                    
                    // Process the data
                    initializeMap();
                    allLocations = processText(rawData);
                    filteredLocations = [...allLocations]; // Initial state is unfiltered
                    populateLocationsList();
                    addMarkersToMap();
                    
                    // Hide loading spinner
                    document.getElementById('loading').style.display = 'none';
                    
                    // Select first location
                    if (filteredLocations.length > 0) {
                        showLocationDetails(filteredLocations[0]);
                    }
                    
                    // Update filter info
                    updateFilterInfo();
                    
                    // Analyze the default keyword (Yoruba)
                    analyzeKeyword();
                },
                error: function(error) {
                    showError("Failed to parse CSV: " + error.message);
                }
            });
        }
        
        // Extract unique years from the data
        function extractYears() {
            const yearSet = new Set();
            
            rawData.forEach(article => {
                // Try to get year from different possible column names
                const year = article.Year || article.year;
                if (year) {
                    yearSet.add(year);
                }
            });
            
            availableYears = Array.from(yearSet).sort();
            console.log("Available years:", availableYears);
        }
        
        // Setup period filter buttons
        function setupPeriodFilters() {
            const periodsContainer = document.getElementById('periods-container');
            periodsContainer.innerHTML = '';
            
            timePeriods.forEach(period => {
                const button = document.createElement('button');
                button.className = 'period-button';
                button.textContent = period.label;
                button.onclick = function() {
                    applyPeriodFilter(period);
                };
                periodsContainer.appendChild(button);
            });
        }
        
        // Apply period filter
        function applyPeriodFilter(period) {
            selectedPeriod = period;
            
            // Update UI for active period
            document.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === period.label) {
                    btn.classList.add('active');
                }
            });
            
            // Filter data to selected period
            const filteredData = rawData.filter(article => {
                const year = article.Year || article.year;
                return year >= period.start && year <= period.end;
            });
            
            // Reprocess text with filtered data
            filteredLocations = processText(filteredData);
            
            // Update map and list
            updateVisualization();
            
            // Update filter info
            updateFilterInfo();
        }
        
        // Reset all filters
        function resetFilters() {
            selectedPeriod = null;
            
            // Reset UI
            document.querySelectorAll('.period-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Use all data
            filteredLocations = [...allLocations];
            
            // Update map and list
            updateVisualization();
            
            // Update filter info
            updateFilterInfo();
        }
        
        // Update filter info text
        function updateFilterInfo() {
            const filterInfo = document.getElementById('filter-info');
            if (selectedPeriod) {
                filterInfo.textContent = `Showing data from ${selectedPeriod.start} to ${selectedPeriod.end}`;
            } else {
                filterInfo.textContent = 'Showing data from all years (1891-1921)';
            }
        }
        
        // Update visualization after filter change
        function updateVisualization() {
            // Clear existing markers
            for (const key in markers) {
                map.removeLayer(markers[key]);
            }
            markers = {};
            
            // Update the list and add new markers
            populateLocationsList();
            addMarkersToMap();
            
            // Select first location or clear details if empty
            if (filteredLocations.length > 0) {
                showLocationDetails(filteredLocations[0]);
            } else {
                document.getElementById('details-container').style.display = 'none';
            }
        }
        
        // Initialize map with OpenStreetMap standard tiles
        function initializeMap() {
            map = L.map('map').setView([15, 10], 2);
            
            // Use OpenStreetMap standard tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);
        }

        // Functions for styling markers
        function getMarkerColor(count) {
            if (count > 300) return "#08306b"; // Very dark blue
            if (count > 150) return "#2171b5";
            if (count > 100) return "#4292c6";
            if (count > 50) return "#6baed6";
            if (count > 25) return "#9ecae1";
            return "#c6dbef"; // Light blue
        }

        function getMarkerRadius(count) {
            return Math.min(25, Math.max(8, Math.log(count) * 3.5));
        }

        // Process the raw text to find and count locations
        function processText(textData) {
            const locationMentions = {};
            const locationArticles = {};
            const locationQuotes = {};
            const locationYears = {}; // Track mentions by year
            
            textData.forEach(article => {
                const text = article.text || "";
                
                // Handle publication date
                let publicationDate = article["Publication Date"] || article["Publication Date "] || "";
                
                // Get year
                const year = article.Year || article.year;
                
                // Track locations found in this article to count unique articles
                const locationsInThisArticle = new Set();
                
                // Search for each location in the text
                for (const location of locationKeywords) {
                    // Case insensitive regex search with word boundaries
                    const regex = new RegExp(`\\b${location}\\b`, 'gi');
                    let matches = [];
                    let match;
                    
                    // Find all matches and collect their positions
                    while ((match = regex.exec(text)) !== null) {
                        matches.push({
                            index: match.index,
                            text: match[0]
                        });
                    }
                    
                    if (matches.length > 0) {
                        // Count mentions
                        locationMentions[location] = (locationMentions[location] || 0) + matches.length;
                        
                        // Track mentions by year
                        if (year) {
                            if (!locationYears[location]) {
                                locationYears[location] = {};
                            }
                            locationYears[location][year] = (locationYears[location][year] || 0) + matches.length;
                        }
                        
                        // Mark this article as containing this location
                        locationsInThisArticle.add(location);
                        
                        // Find the best quotes for this location using improved algorithm
                        if (!locationQuotes[location]) {
                            locationQuotes[location] = [];
                        }
                        
                        // Only find quotes if we need more for this location
                        if (locationQuotes[location].length < 3) { // Store up to 3 quotes for diversity
                            // Score all mentions and find the best ones
                            const scoredMentions = matches.map(match => {
                                const score = evaluateMentionImportance(text, match.index, location);
                                return {
                                    index: match.index,
                                    score: score
                                };
                            });
                            
                            // Sort by score, highest first
                            scoredMentions.sort((a, b) => b.score - a.score);
                            
                            // Select best mention with diversity consideration
                            const selectedMentions = selectDiverseMentions(scoredMentions, text, locationQuotes[location]);
                            
                            // Process selected mentions into quotes
                            selectedMentions.forEach(mention => {
                                const quote = extractQuoteWithSentenceBoundaries(text, mention.index, location);
                                
                                locationQuotes[location].push({
                                    quote: quote,
                                    date: publicationDate,
                                    year: year,
                                    score: mention.score,
                                    articleId: article.no || article.id || 0
                                });
                            });
                        }
                    }
                }
                
                // Count unique articles for each location
                locationsInThisArticle.forEach(location => {
                    locationArticles[location] = (locationArticles[location] || 0) + 1;
                });
            });
            
            // Sort quotes by relevance score
            Object.keys(locationQuotes).forEach(location => {
                locationQuotes[location].sort((a, b) => b.score - a.score);
                // Keep top 3 quotes maximum
                locationQuotes[location] = locationQuotes[location].slice(0, 3);
            });
            
            // Combine the data
            let locationsData = Object.keys(locationMentions).map(name => ({
                name,
                count: locationMentions[name],
                articleCount: locationArticles[name] || 0,
                coordinates: locationCoordinates[name],
                quotes: locationQuotes[name] || [],
                yearData: locationYears[name] || {}
            }));
            
            // Sort by count (most mentions first)
            locationsData.sort((a, b) => b.count - a.count);
            
            // Apply display filter (top N or threshold)
            if (displayMode === "top") {
                return locationsData.slice(0, displayValue);
            } else {
                // Threshold mode - show all locations with count >= threshold
                return locationsData.filter(loc => loc.count >= displayValue);
            }
        }
        
        // Evaluate the importance of a location mention based on its context
        function evaluateMentionImportance(text, index, location) {
            let score = 0;
            
            // 1. Position-based importance
            const positionRatio = index / text.length;
            
            // Beginning of text (introduction) - high importance
            if (positionRatio < 0.2) {
                score += 4;
            }
            // End of text (conclusion) - high importance
            else if (positionRatio > 0.8) {
                score += 3;
            }
            // Middle of text - context-dependent importance
            else {
                score += 1;
            }
            
            // 2. Context-based importance: check for important keywords nearby
            const contextWindow = 100; // Look 100 chars before and after
            const contextStart = Math.max(0, index - contextWindow);
            const contextEnd = Math.min(text.length, index + contextWindow);
            const context = text.substring(contextStart, contextEnd).toLowerCase();
            
            // Check for important contextual keywords
            importantKeywords.forEach(keyword => {
                if (context.includes(keyword.toLowerCase())) {
                    score += 2;
                }
            });
            
            // 3. Density-based importance: Check if location is mentioned multiple times nearby
            const localDensity = countOccurrences(context, location.toLowerCase());
            score += Math.min(3, localDensity - 1); // Add up to 3 points for multiple mentions
            
            // 4. Look for indicators of a focused discussion about the location
            if (context.includes(location.toLowerCase() + " is") || 
                context.includes(location.toLowerCase() + " was") ||
                context.includes(location.toLowerCase() + " has") ||
                context.includes(location.toLowerCase() + " had") ||
                context.includes("in " + location.toLowerCase()) ||
                context.includes("at " + location.toLowerCase()) ||
                context.includes("of " + location.toLowerCase())) {
                score += 3;
            }
            
            // 5. Check if it's at the beginning of a paragraph/sentence
            const prevNewline = text.lastIndexOf('\n', index);
            const prevPeriod = text.lastIndexOf('.', index);
            if ((prevNewline > -1 && index - prevNewline < 50) || 
                (prevPeriod > -1 && index - prevPeriod < 20)) {
                score += 2;
            }
            
            return score;
        }
        
        // Helper function to count occurrences of a substring
        function countOccurrences(text, substr) {
            let count = 0;
            let pos = text.indexOf(substr);
            
            while (pos !== -1) {
                count++;
                pos = text.indexOf(substr, pos + 1);
            }
            
            return count;
        }
        
        // Select diverse mentions to avoid redundancy
        function selectDiverseMentions(scoredMentions, text, existingQuotes) {
            if (scoredMentions.length === 0) return [];
            
            const maxToSelect = 3 - existingQuotes.length;
            if (maxToSelect <= 0) return [];
            
            const selected = [];
            const existingTexts = existingQuotes.map(q => q.quote.toLowerCase());
            
            // Always take the highest scored mention first
            selected.push(scoredMentions[0]);
            
            // Then, add other mentions that are diverse enough
            for (let i = 1; i < scoredMentions.length && selected.length < maxToSelect; i++) {
                const candidateContext = extractContext(text, scoredMentions[i].index, 100);
                
                // Check if this candidate is similar to already selected mentions
                let isDiverse = true;
                
                // Check against existing quotes
                for (const existingText of existingTexts) {
                    const similarity = calculateSimilarity(candidateContext.toLowerCase(), existingText);
                    if (similarity > 0.5) { // More than 50% similar, skip this
                        isDiverse = false;
                        break;
                    }
                }
                
                // Check against already selected mentions in this round
                for (const selectedMention of selected) {
                    const selectedContext = extractContext(text, selectedMention.index, 100);
                    const similarity = calculateSimilarity(candidateContext.toLowerCase(), selectedContext.toLowerCase());
                    if (similarity > 0.5) {
                        isDiverse = false;
                        break;
                    }
                }
                
                if (isDiverse) {
                    selected.push(scoredMentions[i]);
                }
            }
            
            return selected;
        }
        
        // Helper function to extract context around an index
        function extractContext(text, index, windowSize) {
            const start = Math.max(0, index - windowSize);
            const end = Math.min(text.length, index + windowSize);
            return text.substring(start, end);
        }
        
        // Simple text similarity measure (Jaccard similarity on words)
        function calculateSimilarity(text1, text2) {
            const words1 = new Set(text1.split(/\s+/).filter(w => w.length > 3));
            const words2 = new Set(text2.split(/\s+/).filter(w => w.length > 3));
            
            if (words1.size === 0 || words2.size === 0) return 0;
            
            // Find intersection
            let intersection = 0;
            for (const word of words1) {
                if (words2.has(word)) {
                    intersection++;
                }
            }
            
            // Jaccard similarity: size of intersection / size of union
            const union = words1.size + words2.size - intersection;
            return intersection / union;
        }
        
        // Extract quote with proper sentence boundaries
        function extractQuoteWithSentenceBoundaries(text, mentionIndex, location) {
            // Define sentence endings
            const sentenceEndings = ['. ', '! ', '? ', '.\n', '!\n', '?\n'];
            const maxSentences = 3; // Maximum number of sentences to include
            
            // Find the start of the sentence containing the mention
            let sentenceStart = 0;
            for (let i = mentionIndex - 1; i >= 0; i--) {
                if (sentenceEndings.some(ending => text.substring(i - 1, i + 1) === ending)) {
                    sentenceStart = i + 1;
                    break;
                }
            }
            
            // Find previous sentence starts for context
            let contextStart = sentenceStart;
            let sentencesBeforeCount = 0;
            for (let i = sentenceStart - 2; i >= 0 && sentencesBeforeCount < Math.floor(maxSentences / 2); i--) {
                if (sentenceEndings.some(ending => text.substring(i - 1, i + 1) === ending)) {
                    contextStart = i + 1;
                    sentencesBeforeCount++;
                }
            }
            
            // Find the end of the sentence containing the mention
            let sentenceEnd = text.length;
            for (let i = mentionIndex; i < text.length; i++) {
                if (sentenceEndings.some(ending => text.substring(i, i + 2) === ending)) {
                    sentenceEnd = i + 1;
                    break;
                }
            }
            
            // Find next sentence ends for context
            let contextEnd = sentenceEnd;
            let sentencesAfterCount = 0;
            for (let i = sentenceEnd + 1; i < text.length && sentencesAfterCount < Math.floor(maxSentences / 2); i++) {
                if (sentenceEndings.some(ending => text.substring(i, i + 2) === ending)) {
                    contextEnd = i + 1;
                    sentencesAfterCount++;
                }
            }
            
            // Extract the quote with proper context
            let quote = text.substring(contextStart, contextEnd).trim();
            
            // Add ellipsis if we're not at the beginning or end of the text
            if (contextStart > 0) quote = "..." + quote;
            if (contextEnd < text.length) quote = quote + "...";
            
            // For multiple keywords, highlight all possible variants
            if (typeof location === 'string') {
                // Single keyword case (backward compatibility)
                quote = quote.replace(new RegExp(`\\b${location}\\b`, 'gi'), `<strong>${location}</strong>`);
            } else if (Array.isArray(location)) {
                // Multiple keywords case
                location.forEach(keyword => {
                    quote = quote.replace(new RegExp(`\\b${keyword}\\b`, 'gi'), `<strong>${keyword}</strong>`);
                });
            } else {
                // Just highlight the term as-is if we received unexpected type
                quote = quote.replace(new RegExp(`\\b${location}\\b`, 'gi'), `<strong>${location}</strong>`);
            }
            
            return quote;
        }

        // Toggle quotes visibility
        function toggleQuotes() {
            const quoteSection = document.getElementById('quote-section');
            const toggleBtn = document.getElementById('toggle-quotes-btn');
            
            if (quoteSection.style.display === 'none') {
                quoteSection.style.display = 'block';
                toggleBtn.textContent = 'Hide Quotes';
            } else {
                quoteSection.style.display = 'none';
                toggleBtn.textContent = 'Show Quotes';
            }
        }

        // Function to show location details
        function showLocationDetails(location) {
            selectedLocation = location;
            
            // Update the details container
            document.getElementById('details-title').textContent = location.name;
            document.getElementById('details-mentions').textContent = location.count;
            document.getElementById('details-articles').textContent = location.articleCount;
            
            // Reset quotes toggle button
            document.getElementById('toggle-quotes-btn').textContent = 'Show Quotes';
            document.getElementById('quote-section').style.display = 'none';
            
            // Show the details container
            document.getElementById('details-container').style.display = 'block';
            
            // Prepare quotes (but don't show them yet)
            const quotesContainer = document.getElementById('quotes-container');
            quotesContainer.innerHTML = '';
            
            if (location.quotes && location.quotes.length > 0) {
                // Filter quotes by selected period if needed
                let displayQuotes = location.quotes;
                if (selectedPeriod) {
                    displayQuotes = location.quotes.filter(quote => 
                        quote.year >= selectedPeriod.start && quote.year <= selectedPeriod.end
                    );
                }
                
                if (displayQuotes.length > 0) {
                    displayQuotes.forEach(quote => {
                        const quoteElement = document.createElement('div');
                        const formattedDate = quote.date ? quote.date : (quote.year ? quote.year.toString() : 'Unknown date');
                        
                        // Calculate a percentage for the visual meter (normalize score to 0-100%)
                        const relevancePercent = Math.min(100, Math.round((quote.score / 20) * 100));
                        
                        // Create detailed score breakdown for tooltip
                        const scoreDetails = `
                            Raw Score: ${quote.score} / 20
                            Relevance: ${relevancePercent}%
                            
                            Factors that may have contributed:
                            - Position in text
                            - Important keywords nearby
                            - Multiple mentions in same context
                            - Sentence structure and completeness
                            - Paragraph position
                        `;
                        
                        quoteElement.innerHTML = `
                            <blockquote>${quote.quote}</blockquote>
                            <div class="quote-source">Source: ${formattedDate}</div>
                            <div class="quote-relevance" title="${scoreDetails}">
                                Relevance: <span class="relevance-score">${quote.score}/20</span>
                                <div class="relevance-meter" title="${scoreDetails}">
                                    <div class="relevance-fill" style="width: ${relevancePercent}%"></div>
                                </div>
                            </div>
                        `;
                        quotesContainer.appendChild(quoteElement);
                    });
                } else {
                    quotesContainer.innerHTML = '<p>No quotes available for this location in the selected time period.</p>';
                }
            } else {
                quotesContainer.innerHTML = '<p>No quotes available for this location.</p>';
            }
            
            // Highlight the selected location in the list
            document.querySelectorAll('.location-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const selectedElement = document.querySelector(`.location-item[data-name="${location.name}"]`);
            if (selectedElement) {
                selectedElement.classList.add('active');
                
                // Ensure the selected item is visible in the list
                selectedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            
            // Center map on location
            if (location.coordinates) {
                map.setView(location.coordinates, 4);
                if (markers[location.name]) {
                    markers[location.name].openTooltip();
                }
            }
        }

        // Function to populate the locations list
        function populateLocationsList() {
            const locationList = document.getElementById('location-list');
            locationList.innerHTML = '';
            
            filteredLocations.forEach((location, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'location-item';
                listItem.setAttribute('data-name', location.name);
                listItem.innerHTML = `
                    <div class="location-details">
                        <div class="location-name">${index + 1}. ${location.name}</div>
                        <div class="location-count">Mentioned in ${location.articleCount} articles</div>
                    </div>
                    <div class="count-badge">${location.count}</div>
                `;
                
                listItem.addEventListener('click', () => {
                    showLocationDetails(location);
                });
                
                locationList.appendChild(listItem);
            });
        }

        // Function to add markers to the map
        function addMarkersToMap() {
            filteredLocations.forEach(location => {
                if (!location.coordinates) return;
                
                const markerRadius = getMarkerRadius(location.count);
                const markerColor = getMarkerColor(location.count);
                
                const circleMarker = L.circleMarker(location.coordinates, {
                    radius: markerRadius,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.7
                }).addTo(map);
                
                // Create tooltip with period-specific info if a period is selected
                let tooltipContent = `
                    <div>
                        <strong>${location.name}</strong>
                        <div>${location.count} mentions in ${location.articleCount} articles</div>
                    </div>
                `;
                
                if (selectedPeriod) {
                    tooltipContent = `
                        <div>
                            <strong>${location.name}</strong>
                            <div>${location.count} mentions in ${location.articleCount} articles (${selectedPeriod.start}-${selectedPeriod.end})</div>
                        </div>
                    `;
                }
                
                circleMarker.bindTooltip(tooltipContent);
                
                circleMarker.on('click', () => {
                    showLocationDetails(location);
                });
                
                markers[location.name] = circleMarker;
            });
        }

        // Show error message
        function showError(message) {
            const loading = document.getElementById('loading');
            loading.innerHTML = `<div class="error">${message}</div>`;
            loading.style.display = 'flex';
        }
        
        // Function to change display mode (top N or threshold)
        function changeDisplayMode() {
            displayMode = document.getElementById('display-mode').value;
            
            // Adjust label and placeholder based on mode
            const inputEl = document.getElementById('display-value');
            if (displayMode === "top") {
                inputEl.placeholder = "Number";
                inputEl.min = "5";
                inputEl.max = "100";
                if (displayValue > 100) displayValue = 100;
                if (displayValue < 5) displayValue = 5;
            } else {
                inputEl.placeholder = "Minimum";
                inputEl.min = "1";
                inputEl.max = "1000";
                if (displayValue < 1) displayValue = 1;
            }
            
            // Update value display
            inputEl.value = displayValue;
            
            // Update header text
            updateHeaderText();
            
            // Refilter and update visualization
            updateDisplaySetting();
        }
        
        // Function to update display setting (N or threshold value)
        function updateDisplaySetting() {
            const newValue = parseInt(document.getElementById('display-value').value);
            if (!isNaN(newValue) && newValue > 0) {
                displayValue = newValue;
                
                // Update header text
                updateHeaderText();
                
                // Reprocess with current time filter
                if (selectedPeriod) {
                    const filteredData = rawData.filter(article => {
                        const year = article.Year || article.year;
                        return year >= selectedPeriod.start && year <= period.end;
                    });
                    filteredLocations = processText(filteredData);
                } else {
                    filteredLocations = processText(rawData);
                }
                
                // Update visualization
                updateVisualization();
            }
        }
        
        // Update header text based on current settings
        function updateHeaderText() {
            const headerEl = document.getElementById('location-header-text');
            if (displayMode === "top") {
                headerEl.textContent = `Top ${displayValue} Geographic Mentions`;
            } else {
                headerEl.textContent = `Geographic Mentions (${displayValue}+ occurrences)`;
            }
        }
        
        // Function to analyze a specific keyword
        function analyzeKeyword() {
            // Show loading spinner
            document.getElementById('loading').style.display = 'flex';
            
            // Get the keywords from input (may include multiple comma-separated values)
            const keywordInput = document.getElementById('keyword-input').value.trim();
            
            if (!keywordInput) {
                document.getElementById('loading').style.display = 'none';
                return;
            }
            
            // Split input by commas and trim each keyword
            const keywords = keywordInput.split(',').map(k => k.trim()).filter(k => k.length > 0);
            
            if (keywords.length === 0) {
                document.getElementById('loading').style.display = 'none';
                return;
            }
            
            // Process the keyword analysis
            setTimeout(() => {
                // Extract the most relevant quotes for these keywords
                const bestQuotes = extractBestQuotesForMultipleKeywords(keywords, 10);
                
                // Find related terms (using the first keyword as primary, but searching in contexts of all)
                const relatedTerms = findRelatedTermsForMultipleKeywords(keywords);
                
                // Identify themes (using the primary keyword for display but analyzing all)
                const themes = identifyThemesForMultipleKeywords(keywords);
                
                // Get year-by-year mentions for all keywords combined
                const yearlyMentions = getYearlyMentionsForMultipleKeywords(keywords);
                
                // Update results display (using first keyword for display titles)
                const displayKeyword = keywords.length > 1 ? 
                                      `${keywords[0]} (+ variations)` : 
                                      keywords[0];
                
                updateKeywordResults(displayKeyword, bestQuotes, relatedTerms, themes, yearlyMentions);
                
                // Hide loading spinner
                document.getElementById('loading').style.display = 'none';
            }, 100);
        }
        
        // Function to extract the best quotes for multiple keywords
        function extractBestQuotesForMultipleKeywords(keywords, numberOfQuotes = 10) {
            const allQuotes = [];
            
            // Process all articles
            rawData.forEach(article => {
                const text = article.text || "";
                const publicationDate = article["Publication Date"] || article["Publication Date "] || "";
                const year = article.Year || article.year;
                
                // Check for each keyword
                for (const keyword of keywords) {
                    // Find all mentions of this keyword
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    let match;
                    
                    while ((match = regex.exec(text)) !== null) {
                        // Score this mention
                        const score = evaluateMentionImportance(text, match.index, keyword);
                        
                        // Extract quote with proper sentence boundaries
                        const quote = extractQuoteWithSentenceBoundaries(text, match.index, keyword);
                        
                        // Add to quotes collection
                        allQuotes.push({
                            quote: quote,
                            keyword: keyword,
                            date: publicationDate,
                            year: year,
                            score: score,
                            articleId: article.no || article.id || 0
                        });
                    }
                }
            });
            
            // Sort by score (highest first)
            allQuotes.sort((a, b) => b.score - a.score);
            
            // Select diverse quotes to avoid redundancy
            return selectDiverseQuotes(allQuotes, numberOfQuotes);
        }
        
        // Select diverse quotes from a collection of quotes
        function selectDiverseQuotes(quotes, maxQuotes) {
            if (quotes.length <= maxQuotes) return quotes;
            
            const selected = [quotes[0]]; // Always take highest scored quote
            
            for (let i = 1; i < quotes.length && selected.length < maxQuotes; i++) {
                let isDiverse = true;
                
                // Check similarity with already selected quotes
                for (const selectedQuote of selected) {
                    const similarity = calculateSimilarity(
                        quotes[i].quote.toLowerCase(), 
                        selectedQuote.quote.toLowerCase()
                    );
                    
                    if (similarity > 0.5) { // More than 50% similar
                        isDiverse = false;
                        break;
                    }
                }
                
                if (isDiverse) {
                    selected.push(quotes[i]);
                }
            }
            
            return selected;
        }
        
        // Find terms related to multiple keywords
        function findRelatedTermsForMultipleKeywords(keywords) {
            // Context window size (characters on either side of keyword)
            const contextWindowSize = 100;
            
            // Collect all words within context windows
            const wordCounts = {};
            const wordProximity = {}; // Average distance from keyword
            
            rawData.forEach(article => {
                const text = article.text || "";
                
                // For each keyword in the list
                for (const keyword of keywords) {
                    // Find all mentions of this keyword
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    let match;
                    
                    while ((match = regex.exec(text)) !== null) {
                        const keywordPos = match.index;
                        
                        // Extract context around keyword
                        const contextStart = Math.max(0, keywordPos - contextWindowSize);
                        const contextEnd = Math.min(text.length, keywordPos + keyword.length + contextWindowSize);
                        const context = text.substring(contextStart, contextEnd);
                        
                        // Extract words from context
                        const words = context.match(/\b[a-zA-Z]{3,}\b/g) || [];
                        
                        // Count words and calculate proximity
                        words.forEach(word => {
                            word = word.toLowerCase();
                            
                            // Skip all keywords in the list and stop words
                            if (keywords.some(k => k.toLowerCase() === word) || stopWords.includes(word)) {
                                return;
                            }
                            
                            // Count occurrence
                            wordCounts[word] = (wordCounts[word] || 0) + 1;
                            
                            // Calculate proximity (word position relative to keyword in this context)
                            const wordPos = context.toLowerCase().indexOf(word);
                            const distance = Math.abs(wordPos - (keywordPos - contextStart));
                            
                            if (!wordProximity[word]) {
                                wordProximity[word] = { totalDistance: 0, count: 0 };
                            }
                            
                            wordProximity[word].totalDistance += distance;
                            wordProximity[word].count += 1;
                        });
                    }
                }
            });
            
            // Calculate final proximity scores
            Object.keys(wordProximity).forEach(word => {
                wordProximity[word] = wordProximity[word].totalDistance / wordProximity[word].count;
            });
            
            // Create array of related terms with their counts
            const relatedTerms = Object.keys(wordCounts).map(word => ({
                term: word,
                count: wordCounts[word],
                proximity: wordProximity[word]
            }));
            
            // Sort by count (highest first), then by proximity (closest first)
            relatedTerms.sort((a, b) => {
                if (b.count !== a.count) {
                    return b.count - a.count;
                }
                return a.proximity - b.proximity;
            });
            
            // Return top 30 terms
            return relatedTerms.slice(0, 30);
        }
        
        // Identify themes related to multiple keywords
        function identifyThemesForMultipleKeywords(keywords) {
            // Extract the top 100 related terms
            const relatedTerms = findRelatedTermsForMultipleKeywords(keywords).slice(0, 100);
            
            // Define theme categories
            const themeCategories = {
                "Political": ["government", "administration", "political", "policy", "governor", "colony", "colonial", "rule", "ruling", "power", "authority", "council", "chief", "chiefs", "leadership"],
                "Cultural": ["tradition", "traditional", "culture", "language", "customs", "ritual", "ceremonies", "religion", "religious", "spiritual", "heritage", "identity", "beliefs", "practices"],
                "Economic": ["trade", "commercial", "market", "economic", "economy", "business", "commerce", "industry", "industrial", "money", "financial", "goods", "export", "import", "wealth"],
                "Education": ["education", "school", "training", "literacy", "college", "university", "teaching", "learning", "students", "scholars", "knowledge", "educational", "academic"],
                "Social": ["community", "social", "society", "family", "families", "marriage", "women", "men", "children", "youth", "elders", "home", "domestic", "urban", "rural"],
                "Geographic": ["land", "territory", "region", "area", "country", "city", "town", "village", "settlement", "coast", "river", "forest", "north", "south", "east", "west"],
                "Colonial Relations": ["british", "european", "foreign", "governor", "administration", "imperial", "empire", "crown", "colonial", "colonizer", "colonized", "native", "indigenous", "resistance", "control"]
            };
            
            // Count terms in each theme
            const themeCounts = {};
            const themeTerms = {};
            
            relatedTerms.forEach(item => {
                const term = item.term.toLowerCase();
                let foundTheme = false;
                
                for (const [theme, keywords] of Object.entries(themeCategories)) {
                    if (keywords.includes(term)) {
                        themeCounts[theme] = (themeCounts[theme] || 0) + item.count;
                        if (!themeTerms[theme]) {
                            themeTerms[theme] = [];
                        }
                        themeTerms[theme].push(term);
                        foundTheme = true;
                    }
                }
                
                // Terms that don't fit predefined categories
                if (!foundTheme) {
                    themeCounts["Other"] = (themeCounts["Other"] || 0) + item.count;
                    if (!themeTerms["Other"]) {
                        themeTerms["Other"] = [];
                    }
                    themeTerms["Other"].push(term);
                }
            });
            
            // Sort themes by count
            const sortedThemes = Object.keys(themeCounts)
                .map(theme => ({
                    theme,
                    count: themeCounts[theme],
                    terms: [...new Set(themeTerms[theme])].slice(0, 5) // Take 5 unique terms
                }))
                .sort((a, b) => b.count - a.count);
            
            return sortedThemes;
        }
        
        // Get yearly mentions of multiple keywords
        function getYearlyMentionsForMultipleKeywords(keywords) {
            const yearlyMentions = {};
            
            rawData.forEach(article => {
                const text = article.text || "";
                const year = article.Year || article.year;
                
                if (!year) return;
                
                // Initialize count for this article
                let articleCount = 0;
                
                // Count mentions of each keyword
                for (const keyword of keywords) {
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    const matches = text.match(regex);
                    if (matches) {
                        articleCount += matches.length;
                    }
                }
                
                // Add to yearly totals
                if (articleCount > 0) {
                    yearlyMentions[year] = (yearlyMentions[year] || 0) + articleCount;
                }
            });
            
            // Convert to array format
            return Object.keys(yearlyMentions)
                .map(year => ({
                    year: parseInt(year),
                    count: yearlyMentions[year]
                }))
                .sort((a, b) => a.year - b.year);
        }
        
        // Update the keyword analysis results display
        function updateKeywordResults(keyword, quotes, relatedTerms, themes, yearlyMentions) {
            const resultsContainer = document.getElementById('keyword-results');
            resultsContainer.innerHTML = '';
            
            // 1. Create timeline chart
            const timelineSection = document.createElement('div');
            timelineSection.className = 'keyword-section';
            timelineSection.innerHTML = `
                <div class="keyword-section-title">Mentions of "${keyword}" Over Time</div>
                <div class="timeline-chart" id="timeline-chart"></div>
                <div style="text-align: center; font-size: 12px; color: #555; margin-top: 5px;">
                    Click on chart to view enlarged version
                </div>
            `;
            resultsContainer.appendChild(timelineSection);
            
            // Populate timeline chart
            createTimelineChart('timeline-chart', yearlyMentions);
            
            // 2. Create themes section
            const themesSection = document.createElement('div');
            themesSection.className = 'keyword-section';
            themesSection.innerHTML = `
                <div class="keyword-section-title">Main Themes Associated with "${keyword}"</div>
                <div class="theme-container" id="theme-container"></div>
            `;
            resultsContainer.appendChild(themesSection);
            
            // Populate themes
            const themeContainer = document.getElementById('theme-container');
            themes.slice(0, 6).forEach(theme => {
                const themeCard = document.createElement('div');
                themeCard.className = 'theme-card';
                themeCard.innerHTML = `
                    <div class="theme-title">${theme.theme}</div>
                    <div class="theme-words">${theme.terms.join(', ')}</div>
                `;
                themeContainer.appendChild(themeCard);
            });
            
            // 3. Create related terms section
            const termsSection = document.createElement('div');
            termsSection.className = 'keyword-section';
            termsSection.innerHTML = `
                <div class="keyword-section-title">Terms Frequently Appearing with "${keyword}"</div>
                <div class="related-terms" id="related-terms"></div>
            `;
            resultsContainer.appendChild(termsSection);
            
            // Populate related terms
            const termsContainer = document.getElementById('related-terms');
            relatedTerms.slice(0, 25).forEach(term => {
                const termTag = document.createElement('div');
                termTag.className = 'term-tag';
                termTag.innerHTML = `
                    ${term.term}
                    <span class="term-count">${term.count}</span>
                `;
                termsContainer.appendChild(termTag);
            });
            
            // 4. Create quotes section
            const quotesSection = document.createElement('div');
            quotesSection.className = 'keyword-section';
            quotesSection.innerHTML = `
                <div class="keyword-section-title">Most Relevant Quotes about "${keyword}"</div>
                <div id="keyword-quotes-container"></div>
            `;
            resultsContainer.appendChild(quotesSection);
            
            // Populate quotes
            const quotesContainer = document.getElementById('keyword-quotes-container');
            if (quotes.length > 0) {
                quotes.forEach(quote => {
                    const quoteElement = document.createElement('div');
                    const formattedDate = quote.date ? quote.date : (quote.year ? quote.year.toString() : 'Unknown date');
                    
                    // Calculate a percentage for the visual meter
                    const relevancePercent = Math.min(100, Math.round((quote.score / 20) * 100));
                    
                    // Create detailed score breakdown for tooltip
                    const scoreDetails = `
                        Raw Score: ${quote.score} / 20
                        Relevance: ${relevancePercent}%
                        
                        Factors that may have contributed:
                        - Position in text
                        - Important keywords nearby
                        - Multiple mentions in context
                        - Sentence structure and completeness
                        - Paragraph position
                    `;
                    
                    quoteElement.innerHTML = `
                        <blockquote>${quote.quote}</blockquote>
                        <div class="quote-source">Source: ${formattedDate}</div>
                        <div class="quote-relevance" title="${scoreDetails}">
                            Relevance: <span class="relevance-score">${quote.score}/20</span>
                            <div class="relevance-meter" title="${scoreDetails}">
                                <div class="relevance-fill" style="width: ${relevancePercent}%"></div>
                            </div>
                        </div>
                    `;
                    quotesContainer.appendChild(quoteElement);
                });
            } else {
                quotesContainer.innerHTML = '<p>No quotes available for this keyword.</p>';
            }
        }
        
        // Create a timeline chart for yearly mentions
        function createTimelineChart(containerId, yearData) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (yearData.length === 0) {
                container.innerHTML = '<p>No yearly data available for this keyword.</p>';
                return;
            }
            
            // Find maximum count for scaling
            const maxCount = Math.max(...yearData.map(d => d.count));
            
            // Create bar container
            const barContainer = document.createElement('div');
            barContainer.className = 'bar-container';
            container.appendChild(barContainer);
            
            // Create bars for each year
            yearData.forEach(yearItem => {
                const height = (yearItem.count / maxCount * 100);
                
                const bar = document.createElement('div');
                bar.className = 'year-bar';
                bar.style.height = `${height}%`;
                
                const yearLabel = document.createElement('div');
                yearLabel.className = 'year-label';
                yearLabel.textContent = yearItem.year;
                
                const countLabel = document.createElement('div');
                countLabel.className = 'count-label';
                countLabel.textContent = yearItem.count;
                
                bar.appendChild(yearLabel);
                bar.appendChild(countLabel);
                
                barContainer.appendChild(bar);
            });
            
            // Make the chart clickable to show enlarged view
            container.style.cursor = 'pointer';
            container.setAttribute('title', 'Click to enlarge');
            container.onclick = () => {
                showEnlargedChart(yearData);
            };
        }
        
        // Show enlarged chart in modal - 強化修正版
        function showEnlargedChart(yearData) {
            if (!yearData || yearData.length === 0) {
                console.error("No data provided to showEnlargedChart");
                return;
            }
            
            try {
                // Get the current keyword for the title
                const keyword = document.getElementById('keyword-input').value.trim();
                
                // Set modal title
                document.getElementById('modal-chart-title').textContent = `Mentions of "${keyword}" Over Time`;
                
                // Calculate total counts and find max value
                let totalCount = 0;
                let maxCount = 0;
                yearData.forEach(item => { 
                    const count = item.count || 0;
                    totalCount += count;
                    maxCount = Math.max(maxCount, count);
                });
                
                const startYear = yearData[0].year;
                const endYear = yearData[yearData.length-1].year;
                document.getElementById('modal-chart-subtitle').textContent = 
                    `Total ${totalCount} mentions from ${startYear} to ${endYear} (Max: ${maxCount})`;
                
                // Clear previous chart
                const container = document.getElementById('enlarged-chart');
                if (!container) {
                    console.error("Could not find enlarged-chart container");
                    return;
                }
                container.innerHTML = '';
                
                // Create bar container with fixed width based on number of years
                const barContainer = document.createElement('div');
                barContainer.className = 'enlarged-bar-container';
                
                // Important: Set width based on number of bars
                // Each bar is 30px wide with 2px margin on each side
                const containerWidth = yearData.length * 34; // 30px + 2px margin on each side
                barContainer.style.width = `${containerWidth}px`;
                // Ensure minimum width is still 100% of parent
                barContainer.style.minWidth = containerWidth > container.clientWidth ? `${containerWidth}px` : '100%';
                
                container.appendChild(barContainer);
                
                // Scale factor to ensure we don't exceed the container height (with some padding)
                // Reserve 50px at the top for labels
                const maxHeight = 350; // Maximum height for bars in pixels
                const scaleFactor = maxHeight / maxCount;
                
                // Create bars for each year
                yearData.forEach(yearItem => {
                    // Safety check for valid count
                    const count = yearItem.count || 0;
                    
                    // Calculate pixel height (scaled to fit)
                    const heightPixels = Math.max(1, count * scaleFactor);
                    
                    // Create bar element with fixed height in pixels
                    const bar = document.createElement('div');
                    bar.className = 'enlarged-year-bar';
                    bar.style.height = `${heightPixels}px`;
                    
                    // Year label below bar
                    const yearLabel = document.createElement('div');
                    yearLabel.className = 'enlarged-year-label';
                    yearLabel.textContent = yearItem.year;
                    
                    // Count label above bar
                    const countLabel = document.createElement('div');
                    countLabel.className = 'enlarged-count-label';
                    countLabel.textContent = count;
                    
                    // Add labels to bar
                    bar.appendChild(yearLabel);
                    bar.appendChild(countLabel);
                    
                    // Add bar to container
                    barContainer.appendChild(bar);
                });
                
                // Show the modal
                const modal = document.getElementById('chart-modal');
                if (modal) {
                    modal.style.display = 'block';
                    
                    // スクロールの位置を左端に設定
                    setTimeout(() => {
                        barContainer.scrollLeft = 0;
                    }, 100);
                }
            } catch (error) {
                console.error("Error in showEnlargedChart:", error);
            }
        }
        
        // Close the modal - 修正版
        function closeModal() {
            const modal = document.getElementById('chart-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Modal outside click handler - 修正版
        window.onclick = function(event) {
            const modal = document.getElementById('chart-modal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }
        
        // Initialize the file upload functionality
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial values
            document.getElementById('display-mode').value = displayMode;
            document.getElementById('display-value').value = displayValue;
            updateHeaderText();
            
            // Set up enter key in keyword search
            document.getElementById('keyword-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    analyzeKeyword();
                }
            });
        });
    </script>
</body>
</html>